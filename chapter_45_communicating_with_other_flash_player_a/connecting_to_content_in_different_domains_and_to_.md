## Connecting to content in different domains and to AIR applications {#connecting-to-content-in-different-domains-and-to-air-applications}

Flash Player 9 and later, Adobe AIR 1.0 and later

To allow communications only from specific domains, you call the allowDomain() or allowInsecureDomain() method of the LocalConnection class and pass a list of one or more domains that are allowed to access this LocalConnection object, passing one or more names of domains to be allowed.

In earlier versions of ActionScript, LocalConnection.allowDomain() and LocalConnection.allowInsecureDomain() were callback methods that had to be implemented by developers and that had to return a Boolean value. In ActionScript 3.0, LocalConnection.allowDomain() and LocalConnection.allowInsecureDomain() are both built-in methods, which developers can call just like Security.allowDomain() and Security.allowInsecureDomain(), passing one or more names of domains to be allowed.

Flash Player 8 introduced security restrictions on local SWF files. A SWF file that is allowed to access the Internet cannot also have access to the local file system. If you specify localhost, any local SWF file can access the SWF file. If the LocalConnection.send() method attempts to communicate with a SWF file from a security sandbox to which the calling code does not have access, a securityError event(SecurityErrorEvent.SECURITY_ERROR) is dispatched. To work around this error, you can specify the caller&#039;s domain in the receiver&#039;s LocalConnection.allowDomain() method.

There are two special values that you can pass to the LocalConnection.allowDomain() and LocalConnection.allowInsecureDomain() methods: * and localhost. The asterisk value (*) allows access from all domains. The string localhost allows calls to the application from content locally installed, but outside of the application resource directory.

If the LocalConnection.send() method attempts to communicate with an application from a security sandbox to which the calling code does not have access, a securityError event(SecurityErrorEvent.SECURITY_ERROR) is dispatched. To work around this error, you can specify the caller&#039;s domain in the receiver&#039;s LocalConnection.allowDomain() method.

If you implement communication only between content in the same domain, you can specify a connectionName parameter that does not begin with an underscore (_) and does not specify a domain name (for example, myDomain:connectionName). Use the same string in the LocalConnection.connect(connectionName) command.

If you implement communication between content in different domains, you specify a connectionName parameter that begins with an underscore. Specifying the underscore makes the content with the receiving LocalConnection object more portable between domains. Here are the two possible cases:

*   If the string for connectionName does not begin with an underscore, the runtime adds a prefix with the superdomain name and a colon (for example, myDomain:connectionName). Although this ensures that your connection does not conflict with connections of the same name from other domains, any sending LocalConnection objects must specify this superdomain (for example, myDomain:connectionName). If you move the HTML or SWF file with the receiving LocalConnection object to another domain, the runtime changes the prefix to reflect the new superdomain (for example, anotherDomain:connectionName). All sending LocalConnection objects have to be manually edited to point to the new superdomain.
*   If the string for connectionName begins with an underscore (for example, _connectionName), the runtime does not add a prefix to the string. This means the receiving and sending LocalConnection objects use identical strings for connectionName. If the receiving object uses LocalConnection.allowDomain() to specify that connections from any domain will be accepted, you can move the HTML or SWF file with the receiving LocalConnection object to another domain without altering any sending LocalConnection objects.

A downside to using underscore names in connectionName is the potential for collisions, such as when two applications both try to connect using the same connectionName. A second, related downside is security-related. Connection names that use underscore syntax do not identify the domain of the listening application. For these reasons, domain-qualified names are preferred.

Adobe AIR

To communicate with content running in the AIR application security sandbox (content installed with the AIR application), you must prefix the connection name with a superdomain identifying the AIR application. The superdomain string starts with app# followed by the application ID followed by a dot (.) character, followed by the publisher ID (if defined). For example, the proper superdomain to use in the connectionName parameter for an application with the application ID, com.example.air.MyApp, and no publisher ID is: &quot;app#com.example.air.MyApp&quot;. Thus, if the base connection name is “appConnection,” then the entire string to use in the connectionName parameter is: &quot;app#com.example.air.MyApp:appConnection&quot;. If the application has the publisher ID, then the that ID must also be included in the superdomain string: &quot;app#com.example.air.MyApp.B146A943FBD637B68C334022D304CEA226D129B4.1&quot;.

When you allow another AIR application to communicate with your application through the local connection, you must call the allowDomain() of the LocalConnection object, passing in the local connection domain name. For an AIR application, this domain name is formed from the application and publisher IDs in the same fashion as the connection string. For example, if the sending AIR application has an application ID of com.example.air.FriendlyApp and a publisher ID of 214649436BD677B62C33D02233043EA236D13934.1, then the domain string that you would use to allow this application to connect is: app#com.example.air.FriendlyApp.214649436BD677B62C33D02233043EA236D13934.1\. (As of AIR 1.5.3, not all AIR applications have publisher IDs.)